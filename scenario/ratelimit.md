### 1. **明确限流目标**

在实现限流之前，需要明确为什么要限流，以及限流的具体目标。例如：

* 防止系统因瞬时高并发而崩溃。
* 限制某个用户或 IP 的请求频率，避免滥用。
* 保证核心服务的资源分配合理。

例如，一个 API 服务的 QPS（每秒查询率）上限是 1000，你可能需要限制每个用户每分钟最多发送 100 次请求。

---

### 2. **常见的限流算法**

以下是几种主流的限流算法，适用于不同场景：

#### (1) **固定窗口计数器（Fixed Window Counter）**

* **原理**：将时间划分为固定窗口（例如 1 分钟），每个窗口内允许的最大请求数是固定的，窗口结束后计数清零。
* **优点**：简单易实现。
* **缺点**：窗口边界可能导致突刺流量。例如，如果限制 1 分钟 100 次请求，用户可能在第 59 秒和第 61 秒各发 100 次请求，导致短时间内 200 次请求。
* **实现**：使用 Redis 的计数器 + 过期时间。例如：
  ```
  INCR user:123:rate_limit  # 自增计数
  EXPIRE user:123:rate_limit 60  # 设置 60 秒过期
  ```

#### (2) **滑动窗口计数器（Sliding Window Counter）**

* **原理**：在固定窗口的基础上，记录每个请求的时间戳，通过滑动窗口计算当前时间段内的请求数。
* **优点**：平滑流量，避免固定窗口的边界问题。
* **缺点**：需要存储每个请求的时间戳，内存开销较大。
* **实现**：可以用 Redis 的有序集合（ZSET）存储时间戳，定期清理过期数据。

#### (3) **漏桶算法（Leaky Bucket）**

* **原理**：请求进入一个固定容量的“桶”，以恒定速率流出。如果桶满了，新请求被丢弃。
* **优点**：流量平滑，适合需要稳定输出的场景。
* **缺点**：无法应对突发流量。
* **实现**：可以用队列模拟，例如用 Redis List 存储请求，定时处理。

#### (4) **令牌桶算法（Token Bucket）**

* **原理**：系统以固定速率生成令牌，存放在桶中。每次请求需要消耗一个令牌，没有令牌则拒绝请求。
* **优点**：支持突发流量（只要桶里有足够的令牌）。
* **缺点**：实现稍复杂。
* **实现**：可以用 Redis 存储令牌数，定时补充令牌。例如：
  ```
  local key = "rate_limit:user:123"
  local tokens = redis.call("GET", key)
  if tokens and tonumber(tokens) >= 1 then
      redis.call("DECR", key)  -- 消耗令牌
      return 1
  else
      return 0  -- 拒绝请求
  end
  ```

---

### 3. **实现限流的步骤**

#### (1) **选择限流维度**

* **按用户**：限制每个用户的请求频率（需要用户标识，如用户 ID）。
* **按 IP**：限制每个 IP 的请求频率。
* **按服务**：对整个服务设置全局限流。
* **按接口**：对特定 API 单独限流。

#### (2) **选择存储**

* **内存**：适合单机场景，使用本地变量或缓存（如 Guava RateLimiter）。
* **分布式存储**：如 Redis、Memcached，适合分布式系统。

#### (3) **设置限流规则**

* 定义限流阈值，例如每秒 100 次、每分钟 1000 次。
* 配置拒绝策略：直接拒绝、排队等待、降级处理。

### 4. **限流实践中的注意事项**

* **分布式环境**：需要考虑一致性问题，使用分布式锁或原子操作。
* **用户体验**：返回友好的错误信息（如 HTTP 429 Too Many Requests），并建议重试时间。
* **监控与调整**：记录限流日志，结合监控工具（如 Prometheus + Grafana）动态调整阈值。
* **降级预案**：限流触发后，可以切换到备用服务或返回缓存数据。
