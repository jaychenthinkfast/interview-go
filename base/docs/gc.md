Go 语言的垃圾回收（Garbage Collection，简称 GC）采用的是**标记-清除（Mark-and-Sweep）算法**，并在此基础上进行了优化，比如引入了并发标记和三色标记机制，以减少停顿时间（Stop-The-World，简称 STW）。

---

### Go 垃圾回收原理

Go 的垃圾回收是一个自动内存管理机制，旨在回收不再使用的内存对象。其核心流程分为以下几个阶段：

#### 1. **标记阶段（Mark Phase）**

- **目标**：从根对象开始，遍历所有可达对象，标记它们为“存活”。
- **过程**：
  - 从一组被称为“根对象”的起点出发，通过引用关系递归访问所有对象。
  - 使用**三色标记算法**（Tricolor Marking）来区分对象的状态：
    - **白色**：未被访问的对象（可能是垃圾）。
    - **灰色**：已发现但尚未扫描其引用的对象。
    - **黑色**：已扫描完成且确定存活的对象。
  - 标记过程是并发的，Go 的垃圾回收器与应用程序的 Goroutine 同时运行（通过写屏障技术保证一致性）。
- **写屏障（Write Barrier）**：在并发标记期间，如果应用程序修改了对象引用（例如将一个黑色对象指向一个白色对象），写屏障会确保新引用的对象被标记为灰色，防止遗漏。

#### 2. **清除阶段（Sweep Phase）**

- **目标**：回收未被标记为存活的对象（即白色对象）。
- **过程**：
  - 遍历堆内存，释放所有未被标记的对象。
  - 清除过程通常是惰性的（lazy sweeping），即在需要分配新内存时逐步完成，而不是一次性清理整个堆。
  - Go 1.5 之后引入了并发清除，进一步减少 STW 时间。

#### 3. **触发时机**

- Go 的 GC 是自动触发的，主要依据堆内存的使用情况。
- **GC Pacing**（节奏控制）：Go 使用一个动态调整的阈值（由 `GOGC` 环境变量控制，默认为 100），表示当堆内存增长到上一次 GC 后存活内存的两倍时触发 GC。例如：
  - 如果上一次 GC 后存活内存为 4MB，当堆内存增长到 8MB 时触发下一次 GC。
  - 用户可以通过调整 `GOGC` 来控制 GC 的频率（值越大，GC 频率越低）。

#### 4. **优化特性**

- **并发性**：标记和清除阶段尽量与应用程序并发运行，仅在关键点（如标记开始和结束）需要短暂的 STW。
- **分代思想**：虽然 Go 没有明确的“分代 GC”，但其设计倾向于优先回收短生命周期对象（通过栈分配和逃逸分析优化）。
- **栈分配**：如果对象不会逃逸到堆上，Go 会直接在栈上分配，避免 GC 开销。

---

### 垃圾回收的根对象

在标记阶段，垃圾回收器需要从一组“根对象”开始遍历。这些根对象是程序中必然存活的起点，通常是应用程序直接可访问的内存区域。Go 中的根对象包括以下几种：

1. **全局变量（Global Variables）**

   - 定义在包级别或全局作用域中的变量。
   - 这些变量在程序运行期间始终存活，因此是 GC 的根。
2. **栈上的变量（Stack Variables）**

   - 所有 Goroutine 的调用栈中当前活跃的局部变量。
   - 包括函数参数、返回值以及临时变量。
   - 注意：如果局部变量通过逃逸分析被分配到堆上，它们不再是根，而是通过栈上的指针间接引用。
3. **寄存器中的指针（Registers）**

   - CPU 寄存器中存储的指向堆内存的指针。
   - 在 Goroutine 执行过程中，寄存器可能临时持有指向堆对象的引用。
4. **运行时数据结构（Runtime Data Structures）**

   - Go 运行时维护的一些关键数据结构中存储的指针，例如：
     - Goroutine 的调度信息。
     - 内存分配器（memory allocator）的元数据。
     - 某些 finalizer（终结器）关联的对象。
5. **已注册的 Finalizer（Finalizers）**

   - 通过 `runtime.SetFinalizer` 注册的对象的引用。
   - 在对象被回收前，finalizer 会确保其暂时存活，因此它们也是根。

---

### 举例说明根对象

假设有以下 Go 代码：

```go
package main

import "runtime"

var globalPtr *int

func main() {
    x := 42
    globalPtr = &x // x 逃逸到堆上

    y := 100
    localPtr := &y // y 未逃逸，仍在栈上

    runtime.GC() // 手动触发 GC
}
```

- **根对象分析**：

  - `globalPtr`：全局变量，指向堆上的 `x`，是根对象。
  - `localPtr`：栈上的局部变量，指向栈上的 `y`，也是根对象。
  - `x`：虽然是局部变量，但因逃逸到堆上，它本身不是根，而是通过 `globalPtr` 间接存活。
  - `y`：未逃逸，分配在栈上，由 `localPtr` 直接引用。
- **GC 过程**：

  - 从 `globalPtr` 和 `localPtr` 开始标记，`x` 和 `y` 都被标记为存活。
  - 其他未被引用的堆对象（如果有）将被清除。

---

### 总结

- **原理**：Go 的垃圾回收基于标记-清除算法，结合三色标记和并发机制，通过写屏障优化性能。
- **根对象**：
  1. 全局变量
  2. 栈上的变量（通常是引用堆内存的指针）
  3. 寄存器中的指针
  4. 运行时数据结构
  5. 已注册的 Finalizer
