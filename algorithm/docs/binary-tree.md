# 二叉树

## 树
* “高度” 从最底层开始计数，并且计数的起点是 0。
* “深度” 从根结点开始度量，并且计数起点也是 0。
* “层数”跟深度的计算类似，不过，计数起点是 1，也就是说根节点位于第 1 层。

## 二叉树
### 满二叉树
除了叶子节点之外，每个节点都有左右两个子节点
### 完全二叉树
叶子节点都在最底下两层，最后一层的叶子节点都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大

### 存储二叉树
#### 链式存储法
每个节点有三个字段，其中一个存储数据，另外两个是指向左右子节点的指针。
#### 顺序存储法
如果节点 X 存储在数组中下标为 i 的位置，下标为 2 * i 的位置存储的就是左子节点，
下标为 2 * i + 1 的位置存储的就是右子节点。

如果某棵二叉树是一棵完全二叉树，那用数组存储无疑是最节省内存的一种方式。

**堆其实就是一种完全二叉树，最常用的存储方式就是数组。**

## 二叉查找树
### 定义
二叉查找树是为了实现快速查找而生的。
二叉查找树要求，在树中的任意一个节点，其左子树中的每个节点的值，
都要小于这个节点的值，而右子树节点的值都大于这个节点的值。

中序遍历二叉查找树，可以输出有序的数据序列，时间复杂度是 O(n)，非常高效。
因此，二叉查找树也叫作二叉排序树。

### 查找性能
极度不平衡的二叉查找树，它的查找性能肯定不能满足我们的需求。

我们需要构建一种不管怎么删除、插入数据，在任何时候，
都能保持任意节点左右子树都比较平衡的二叉查找树，
平衡二叉查找树。平衡二叉查找树的高度接近 logn，所以插入、删除、
查找操作的时间复杂度也比较稳定，是 O(logn)。

### 二叉查找树vs散列表
1. 散列表中的数据是无序存储的，如果要输出有序的数据，需要先进行排序。
   而对于二叉查找树来说，我们只需要中序遍历，就可以在 O(n) 的时间复杂度内，
   输出有序的数据序列。
   
2. 散列表扩容耗时很多，而且当遇到散列冲突时，性能不稳定，尽管二叉查找树的性能不稳定，
   但是在工程中，我们最常用的平衡二叉查找树的性能非常稳定，时间复杂度稳定在 O(logn)。
   
3. 散列表的构造比二叉查找树要复杂，需要考虑的东西很多。 
   比如散列函数的设计、冲突解决办法、扩容、缩容等。平衡二叉查找树只需要考虑平衡性这一个问题，
   而且这个问题的解决方案比较成熟、固定。
   
4. 为了避免过多的散列冲突，散列表装载因子不能太大，特别是基于开放寻址法解决冲突的散列表，
   不然会浪费一定的存储空间。

## 参考
* [**数据结构与算法之美**](http://gk.link/a/10p9l)