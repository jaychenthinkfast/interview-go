# 图
## 定义
和树比起来，这是一种更加复杂的**非线性表结构**

**顶点（vertex）**

图中的一个顶点可以与任意其他顶点建立连接关系。我们把这种建立的关系叫做**边（edge）**

**度（degree）**，就是跟顶点相连接的边的条数

有方向的图叫做“**有向图**”。没有方向的图就叫做“无向图”。

有向图中，我们把度分为**入度（In-degree）和出度（Out-degree）**

带权图中，每条边都有一个**权重（weight）**（应用：可以通过这个权重来表示好友间的亲密度）

## 存储方法
* 邻接矩阵（Adjacency Matrix）
* 邻接表（Adjacency List）

邻接矩阵存储方法的缺点是比较浪费空间，但是优点是查询效率高，而且方便矩阵运算。
邻接表存储方法中每个顶点都对应一个链表，存储与其相连接的其他顶点。
尽管邻接表的存储方式比较节省存储空间，但链表不方便查找，所以查询效率没有邻接矩阵存储方式高。
针对这个问题，邻接表还有改进升级版，即将链表换成更加高效的动态数据结构，
比如平衡二叉查找树、跳表、散列表等。

小规模的数据 存内存

大规模可以哈希分片存到多机器内存，也可以考虑外部存储（磁盘）比如使用数据库表（对字段增加索引加速）来持久化

>q:1.用邻接表自己存
2.关系型库
3.图数据库 的选型
> 
> a:1 内存中用临界表
2 要持久化存储就用数据库
2 超大图 并且涉及大量图计算。用专业的图数据库

## 广度深度优先搜索
广度优先搜索和深度优先搜索是图上的两种最常用、最基本的搜索算法，比起其他高级的搜索算法，比如 A*、IDA* 等，要简单粗暴，没有什么优化，所以，也被叫作暴力搜索算法。
所以，这两种搜索算法仅适用于状态空间不大，也就是说**图不大的搜索**。

广度优先搜索，通俗的理解就是，地毯式层层推进，从起始顶点开始，依次往外遍历。
广度优先搜索需要**借助队列**来实现，遍历得到的路径就是，起始顶点到终止顶点的最短路径。

深度优先搜索用的是**回溯思想**，非常适合用**递归**实现。换种说法，深度优先搜索是借助**栈**来实现的。

在执行效率方面，深度优先和广度优先搜索的时间复杂度都是 O(E)，空间复杂度是 O(V)。
## 参考
* [**数据结构与算法之美**](http://gk.link/a/10p9l)
