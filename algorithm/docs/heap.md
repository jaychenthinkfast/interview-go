# 堆
## 定义
堆排序是一种原地的、时间复杂度为 O(nlogn) 的排序算法。

* 堆是一个完全二叉树；

    除了最后一层，其他层的节点个数都是满的，最后一层的节点都靠左排列。
* 堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值。

## 复杂度
往堆中插入一个元素和删除堆顶元素的时间复杂度都是 O(logn)

整个堆排序的过程，都只需要极个别临时存储空间，所以堆排序是原地排序算法。
堆排序包括建堆和排序两个操作，建堆过程的时间复杂度是 O(n)，排序过程的时间复杂度是 O(nlogn)，
所以，堆排序整体的时间复杂度是 O(nlogn)。

堆排序不是稳定的排序算法

## 堆排序vs 快速排序
对于快速排序来说，数据是顺序访问的。而对于堆排序来说，数据是跳着访问的。
（对堆顶节点进行堆化，会依次访问数组下标是 1，2，4，8 的元素，而不是像快速排序那样，局部顺序访问，所以，这样对 CPU 缓存是不友好的）
这样对 CPU 缓存是不友好的。

建堆的过程会打乱数据原有的相对先后顺序，导致原数据的有序度降低。比如，对于一组已经有序的数据来说，经过建堆之后，数据反而变得更无序了。
堆排序算法的数据交换次数要多于快速排序。

## 应用
* 优先级队列
* TopK问题

  只需要利用一个堆，就可以做到非常高效率地查询 Top K 的数据
* 求中位数

  还有很多变形，比如求 99 百分位数据、90 百分位数据等，处理的思路都是一样的，即利用两个堆，一个大顶堆，一个小顶堆，随着数据的动态添加，动态调整两个堆中的数据，最后大顶堆的堆顶元素就是要求的数据。
  **动态数据时相较于数组因为插入元素涉及到搬迁复杂度O（n),而建堆虽然耗时，但是只需要建一次，之后插入数据，只需要logk的时间复杂度。**
## 参考
* [**数据结构与算法之美**](http://gk.link/a/10p9l)

