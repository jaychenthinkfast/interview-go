# 字符串匹配

## BF 算法（Brute Force）
### 定义
暴力匹配算法，也叫朴素匹配算法

我们在主串中，检查起始位置分别是 0、1、2....n-m 且长度为 m 的 n-m+1 个子串，看有没有跟模式串匹配的。

### 复杂度
时间复杂度是 O(n*m)

### 场景
处理小规模的字符串匹配

>q:BF 算法的时间复杂度很高，是 O(n*m)，但在实际的开发中，它却是一个比较常用的字符串匹配算法。
> 
> a:实际的软件开发中，大部分情况下，模式串和主串的长度都**不会太长**。而且每次模式串与主串中的子串匹配的时候，
> 当中途遇到**不能匹配的字符的时候，就可以就停止了**，不需要把 m 个字符都比对一下。
> 朴素字符串匹配算法思想简单，**代码实现也非常简单**。

## RK 算法(Rabin-Karp)
### 定义
对 BF 算法进行改造，即对每个子串分别求哈希值，然后拿子串的哈希值与模式串的哈希值比较，减少了比较的时间。

### 复杂度
计算子串哈希值需扫一次主串计算时间复杂度 O(n)，比较子串和模式串n-m+1 次，
综合后时间复杂度是 O(n)，跟 BF 算法相比，效率提高了很多。不过这样的效率取决于哈希算法的设计方法，
如果存在冲突的情况下，时间复杂度可能会退化。极端情况下，哈希算法大量冲突，时间复杂度就退化为 O(n*m)。

## BM 算法（Boyer-Moore）
### 定义
BM 算法核心思想是，利用模式串本身的特点，在模式串中某个字符与主串不能匹配的时候，将模式串往后多滑动几位，
以此来减少不必要的字符比较，提高匹配的效率。BM 算法构建的规则有两类，坏字符规则和好后缀规则。
好后缀规则可以独立于坏字符规则使用。因为坏字符规则的实现比较耗内存，为了节省内存，我们可以只用好后缀规则来实现 BM 算法。
### 复杂度
O(n)
### 场景
* 文本编辑器中的查找替换功能
* grep
>产生背景：在某些极端情况下，BF 算法性能会退化的比较严重，而 RK 算法需要用到哈希算法，设计一个可以应对各种类型字符的哈希算法并不简单。
> 它是一种非常高效的字符串匹配算法，有实验统计，它的性能是著名的KMP 算法的 3 到 4 倍。

## 参考
* [**数据结构与算法之美**](http://gk.link/a/10p9l)
