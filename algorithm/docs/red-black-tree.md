# 红黑树
## 平衡二叉查找树
### 严格定义
二叉树中任意一个节点的左右子树的高度相差不能大于 1。还需满足二叉查找树的特点。
最先被发明的平衡二叉查找树是AVL 树，它严格符合我刚讲到的平衡二叉查找树的定义，
即任何节点的左右子树高度相差不超过 1，是一种高度平衡的二叉查找树。
### 宽松定义
只要树的高度不比 log2n 大很多（比如树的高度仍然是对数量级的），
尽管它不符合严格的平衡二叉查找树的定义，但仍可以说，这是一个合格的平衡二叉查找树。

## 红黑树
* 根节点是黑色的；
* 每个叶子节点都是黑色的空节点（NIL），也就是说，叶子节点不存储数据；
* 任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的；
* 每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点；

AVL 树是一种高度平衡的二叉树，所以查找的效率非常高，
但是，有利就有弊，AVL 树为了维持这种高度的平衡，就要付出更多的代价。
每次插入、删除都要做调整，就比较复杂、耗时。
所以，对于有频繁的插入、删除操作的数据集合，使用 AVL 树的代价就有点高了。
红黑树只是做到了近似平衡，并不是严格的平衡，所以在**维护平衡的成本上**，要比 AVL 树要低。

### 动态数据结构对比
散列表：插入删除查找都是O(1), 是最常用的，但其缺点是不能顺序遍历以及扩容缩容的性能损耗。适用于那些不需要顺序遍历，数据更新不那么频繁的。

跳表：插入删除查找都是O(logn), 并且能顺序遍历。缺点是空间复杂度O(n)。适用于不那么在意内存空间的，其顺序遍历和区间查找非常方便。

红黑树：插入删除查找都是O(logn), 中序遍历即是顺序遍历，稳定。缺点是难以实现，去查找不方便。其实跳表更佳，但红黑树已经用于很多地方了。
## 参考
* [**数据结构与算法之美**](http://gk.link/a/10p9l)